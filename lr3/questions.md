# Ответы на вопросы

1) В чем разница между fail-safe и fail-fast свойствами?

### Ответ: `Fail-fast` и `fail-safe` представляют две разные стратегии обработки ошибок при работе с коллекциями. Итераторы `fail-fast` были введены для обеспечения безопасности при работе с многопоточными коллекциями. Они выбрасывают исключение ConcurrentModificationException, если структура коллекции изменяется во время итерации. С другой стороны, итераторы `fail-safe` работают с копией коллекции и не выбрасывают исключений при изменениях, но могут не увидеть часть свежих изменений, что может привести к неконсистентности данных.
---
2) В чем разница между Iterator и Enumeration?

### Ответ: Разница между `Iterator` и `Enumeration` заключается в их функциональности. `Iterator` является универсальным курсором, применимым ко всем классам коллекций. Он позволяет выполнять операции чтения и удаления элементов. В отличие от Iterator, Enumeration применим только к устаревшим классам и не позволяет удалять элементы во время итерации. `Iterator` предпочтительно использовать для манипуляций с коллекциями, в то время как Enumeration предназначен для доступа только для чтения.
---
3) В чем разница между Iterator и ListIterator?

### Ответ: Разница между `Iterator` и `ListIterator` в Java заключается в их функциональности при итерации по коллекциям. Iterator может перебирать элементы только в прямом направлении, в то время как ListIterator позволяет перебирать элементы как в прямом, так и в обратном направлении. ListIterator применим только к классам коллекций, реализующим интерфейс List, в то время как Iterator может использоваться для перебора элементов в Set, List и Map. ListIterator обладает дополнительными методами, такими как `set(), add(), previous(), nextIndex()` и `previousIndex()`, что делает его более функциональным по сравнению с Iterator. Таким образом, основное различие между ними заключается в возможности ListIterator работать с коллекциями в обоих направлениях и предоставлять дополнительные методы для манипуляций с элементами коллекции.
---
4) Дайте определение понятию “итератор”

### Ответ: `Итератор` - это объект, который позволяет перебирать элементы коллекции по одному. Он предоставляет методы для доступа к элементам коллекции без раскрытия ее внутренней структуры. Итераторы позволяют обходить коллекции различных типов, таких как `List, Set и Map`, и выполнять операции чтения и удаления элементов в процессе итерации.
---
5) Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

### Ответ: Порядок следования объектов в коллекции может быть задан либо естественным порядком элементов, либо объектом, реализующим интерфейс сравнения `Comparator`. Для сортировки коллекции можно использовать классы, такие как `TreeSet, TreeMap`, которые автоматически сортируют элементы в упорядоченном виде. Например, при использовании TreeSet с Comparator можно задать специфический порядок сортировки элементов в коллекции. Таким образом, для управления порядком следования объектов в коллекции и их сортировки, можно использовать естественный порядок элементов или определить специальный порядок с помощью `Comparator`.
---
6) Как получить коллекцию только для чтения?

### Ответ: Для создания коллекции только для чтения в Java можно воспользоваться методом `Collections.unmodifiableCollection()`. Этот метод принимает исходную коллекцию и возвращает ее неизменяемую версию, которую нельзя изменить после создания. Например, чтобы создать неизменяемый список, можно использовать следующий код:

```java
List<String> originalList = new ArrayList<>();
originalList.add("Item 1");
originalList.add("Item 2");

List<String> readOnlyList = Collections.unmodifiableList(originalList);
```

Теперь `readOnlyList` будет содержать те же элементы, что и `originalList`, но нельзя будет добавить, удалить или изменить элементы в `readOnlyList`.

Аналогично, для создания неизменяемого множества или карты можно использовать `Collections.unmodifiableSet()` и `Collections.unmodifiableMap()` соответственно.

Этот подход полезен, когда требуется предоставить доступ к коллекции только для чтения, чтобы избежать случайных изменений данных или обеспечить безопасность в многопоточной среде.
---
7) Как получить не модифицируемую коллекцию?

### Ответ: Так же как и коллекцию только для чтения - используя `Collections.unmodifiableCollection()`.
---
8) 
   
### Ответ: Для получения синхронизированной коллекции из несинхронизированной в Java можно использовать статические методы класса Collections, который оборачивает существующую коллекцию и обеспечивает синхронизированный доступ к ней. Например, чтобы создать синхронизированный список из существующего ArrayList, можно использовать следующий код:
```java
List<String> myList = new ArrayList<>();
List<String> synchronizedList = Collections.synchronizedList(myList);
```
---
9) Как реализован цикл foreach?

### Ответ: foreach - синтаксический сахар и упрощенная версия для перебора коллекций. Под капотом цикл foreach переводится компилятором в традиционный цикл for, который использует итератор для перебора элементов коллекции или массива. Цикл foreach оптимизирован для читаемости и простоты, и он в основном рекомендуется для большинства случаев использования, когда вам нужно перебрать коллекцию или массив.Однако важно отметить, что у цикла foreach есть некоторые ограничения. Например, он не может быть использован для изменения коллекции, над которой выполняется итерация. Если попытаться изменить коллекцию, то будет получено сообщение ConcurrentModificationException.
---
10) 
